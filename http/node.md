> 本篇笔记主要学习阮一峰的相关文章整理的笔记
> - [http](https://www.ruanyifeng.com/blog/2016/08/http.html)
> - [https](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
- http发展史
  - http/0.9
    - 只能发送`GET`请求
    - 服务器只能回应HTML格式的字符串, 且服务器发送完毕之后, 就关闭了TCP连接
  - http/1.0
    - 浏览器和服务器互动的手段增多了, 除了`GET`命令, 还引入了`POST`和`HEAD`命令
    - 任何格式的内容都可以发送: 图像, 视频, 二进制文件...
    - http请求和回应的格式也发生了变化
    - 缺点: 每个`TCP`连接只能发送一次请求, 当时使用了非标准的`Connection`字段解决这一问题, 不同实现的行为可能不一致, 所以不能解决根本问题
      ```json
        Connection: keep-alive
      ```
  - http/1.1
    - 引入了持久连接, 即`TCP`连接默认不关闭, 可以被多个请求复用
    - 管道机制: 在同一个`TCP`连接里面, 客户端可以同时发送多个请求, 但服务器还是会按照顺序依次回应
    - 新增了`PUT`, `PATCH`, `OPTIONS`, `DELETE`, 'HEAD
    - 客户端请求的头信息新增了`Host`字段, 用来指定服务器的域名
    - 缺点: 即使可以复用`TCP`连接, 但服务器只有处理完一个回应才会进行下一个回应, 要是前面的回应特别慢, 后面就会有许多请求排队等着
  - http/2
    - 二进制协议
      - http/1.1版的头信息是文本(ASCII编码), 数据体可以是文本, 也可以是二进制
      - http/2 头信息和数据体都是二进制, 并统称为'帧'
    - 多工
      - 在一个连接里, 客户端和浏览器都可以同时发送多个请求和回应, 而且不应按照顺序一一对应
    - 数据流
      - http/2 将每个请求或呼应的所有数据包, 称为一个数据流, 每个数据流都有独一无二的编号
      - 数据包发送的时候, 必须标记数据流ID
      - 规定客户端发出的数据流, ID为奇数; 服务器发出的, ID为偶数
      - 客户端还可以指定数据流的优先级, 优先级越高, 服务器就会越早响应
    - 头信息压缩
      - http协议不带状态, 每次请求都必须附上所有的信息, 所以很多请求字段都是重复的, 比如`Cookie`和`User Agent`
      - http/2
        - 头信息使用`gzip`和`compress`压缩后再发送
        - 客户端和服务器同时维护一张头信息表, 所有字段都会存于这个表, 生成一个索引号, 以后就不发送同样的字段, 只发送索引号, 大大提高了速度
    - 服务器推送
      - http/2 允许服务器未经允许, 主动向客户端发送资源;
        - 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了

- https
  - https协议是由`SSL + HTTP`协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
  - 作用
    - 不使用`SSL/TLS`的http通信, 不加密的的通信, 所有信息铭文传播, 带来以下风险
      - 窃听风险: 第三方可以获取通信内容
      - 篡改风险: 第三方可以修改通信内容
      - 冒充风险: 第三方可以冒充他人身份参与通信
    - `SSL/TLS`协议就是为了解决以上风险而设计的, 希望达到
      - 所有信息都是加密传播, 第三方无法窃听
      - 具有校验机制, 一旦被篡改, 通信双方会立刻发现
      - 配备身份证书, 防止身份被冒充

- http缓存
  - 一般说http缓存, 都是指的GET请求
  - `强制缓存`
    - 命中缓存, 且未失效, 则从缓存数据库获取请求数据, 请求状态码为`200`
    - 缓存未命中, 则会继续向服务器请求数据, 服务器返回数据和缓存规则, 客户端将数据和缓存规则存于缓存数据库
    - 缺点: 如果缓存在未失效的期间, 服务端的资源有改动, 则拿不到最新的数据
  - `协商缓存`
    - 命中缓存, 从缓存数据库获取缓存数据的标识, 接着请求服务器验证缓存标识对应的数据是否失效, 服务端通知客户端未失效, 获取缓存数据, 请求状态码为`304`
    - 缓存未命中, 依旧先从缓存数据库获取缓存数据的标识, 然后请求服务器验证缓存标识对应的数据是否失效, 服务端验证失效之后, 直接返回最新的数据和缓存规则, 客户端将数据和缓存规则存于缓存数据库
  - 对比上面两种缓存规则, 强制缓存如果生效, 则不与服务器发生交互; 而协商缓存不管是否生效都会与服务端发生交互
  - 两种缓存规则同时生效时, `强制缓存`优先于`协商缓存`